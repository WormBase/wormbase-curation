<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#FILES">FILES</a></li>
      <li><a href="#POSTGRES-TABLES">POSTGRES TABLES</a>
        <ul>
          <li><a href="#GENERAL-POSTGRES-TABLES">GENERAL POSTGRES TABLES</a></li>
          <li><a href="#DATATYPE-POSTGRES-TABLES">DATATYPE POSTGRES TABLES</a></li>
          <li><a href="#OBO-POSTGRES-TABLES">OBO POSTGRES TABLES</a></li>
        </ul>
      </li>
      <li><a href="#GLOBALS">GLOBALS</a>
        <ul>
          <li><a href="#OA-GLOBALS">OA GLOBALS</a></li>
          <li><a href="#OTHER-GLOBALS">OTHER GLOBALS</a></li>
        </ul>
      </li>
      <li><a href="#SUBROUTINES">SUBROUTINES</a>
        <ul>
          <li><a href="#LOGIN-SUBROUTINE">LOGIN SUBROUTINE</a></li>
          <li><a href="#INITIALIZATION-SUBROUTINE">INITIALIZATION SUBROUTINE</a></li>
          <li><a href="#SHOW-MAIN-SUBROUTINE">SHOW MAIN SUBROUTINE</a></li>
          <li><a href="#SHOW-EDITOR-SUBROUTINES">SHOW EDITOR SUBROUTINES</a></li>
          <li><a href="#SHOW-OBO-SUBROUTINES">SHOW OBO SUBROUTINES</a></li>
          <li><a href="#SHOW-CONTROLS-SUBROUTINE">SHOW CONTROLS SUBROUTINE</a></li>
          <li><a href="#SHOW-TABLE-SUBROUTINE">SHOW TABLE SUBROUTINE</a></li>
          <li><a href="#JSON-FIELD-QUERY-SUBROUTINES">JSON FIELD QUERY SUBROUTINES</a></li>
          <li><a href="#AUTOCOMPLETE-SUBROUTINES">AUTOCOMPLETE SUBROUTINES</a></li>
          <li><a href="#ASYNC-TERM-INFO-SUBROUTINE">ASYNC TERM INFO SUBROUTINE</a></li>
          <li><a href="#ASYNC-VALID-VALUE-SUBROUTINES">ASYNC VALID VALUE SUBROUTINES</a></li>
          <li><a href="#UPDATE-POSTGRES-TABLE-FIELD-SUBROUTINES">UPDATE POSTGRES TABLE FIELD SUBROUTINES</a></li>
          <li><a href="#UPDATE-POSTGRES-COLUMN-SUBROUTINE">UPDATE POSTGRES COLUMN SUBROUTINE</a></li>
          <li><a href="#NEW-ROW-SUBROUTINES">NEW ROW SUBROUTINES</a></li>
          <li><a href="#DUPLICATE-BY-PGIDS-SUBROUTINE">DUPLICATE BY PGIDS SUBROUTINE</a></li>
          <li><a href="#DELETE-BY-PGIDS-SUBROUTINE">DELETE BY PGIDS SUBROUTINE</a></li>
          <li><a href="#CHECK-DATA-BY-PGIDS-SUBROUTINES">CHECK DATA BY PGIDS SUBROUTINES</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>ontology_annotator.cgi - Main file with code for ontology_annotator. CGI for curators to load and make curations through a web browser (tested with Mozilla&#39;s Firefox).</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>Place on webserver with ontology_annotator.css, ontology_annotator.js, helperOA.pm, yui/ and images/ directories, and MOD-specific perl module (e.g. testOA.pm , wormOA.pm). Create appropriate MOD-specific perl module for your MOD, in that module add settings for each datatype to curate, and create a postgres table for each datatypes&#39;s fields. Requires web server, CGI, and postgreSQL.</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>CGI file for curators to load through a web browser. When using for a new MOD, create a MOD-specific perl module (see testOA.pm for template and instructions, or wormOA.pm for example and instructions). In this file add to :</p>

<ul>

<li><p>add &quot;use testOA;&quot; (only add one module, the exported subroutines have the same name)</p>

</li>
<li><p>add &quot;my $configLoaded = &#39;testOA&#39;;&quot;</p>

</li>
</ul>

<h2 id="FILES">FILES</h2>

<p>ontology_annotator.css REQUIRED has the css properties to display one row in each dataTable, show red squares in dataTable cells that have data not showing, extra padding on autocomplete results div html elements.</p>

<p>ontology_annotator.js REQUIRED has all the Ontology Annotator-specific javascript code.</p>

<p>helperOA.pm REQUIRED perl module that has helper subroutines for the main CGI and MOD-specific perl modules. Get and untaint form variables. Get timestamps in postgres format.</p>

<p>yui/ REQUIRED directory to hold local copies of the necessary YUI&#39;s .js files. YUI&#39;s website is fast and reliable, but just in case keep a local copy.</p>

<p>images/ REQUIRED directory to hold necessary images. The red square for dataTable cells with more data than showing. Loading image when querying.</p>

<p>MOD-specific perl modules. REQUIRED. See testOA.pm, wormOA.pm for examples.</p>

<p>docs/ OPTIONAL directory to hold html files documenting how scripts, modules, and the CGI work. Generated by scripts/generateDocs.pl .</p>

<p>scripts/ OPTIONAL directory to hold perl scripts to generate tables, update ontologies, generate documentation.</p>

<h2 id="POSTGRES-TABLES">POSTGRES TABLES</h2>

<p>There are general postgres tables required for all MODs and datatypes, for curator settings. There are datatype-specific postgres tables for each MOD&#39;s datatypes&#39;s field. See below for specific formats.</p>

<p>Be sure to GRANT ALL on each table to postgres and the webserver user.</p>

<p>Note: It&#39;s very likely that a different flavor of SQL may be used with minor code change, but this has not been tested.</p>

<h3 id="GENERAL-POSTGRES-TABLES">GENERAL POSTGRES TABLES</h3>

<p>For the OA to remember a given curator-datatype-field dataTable column&#39;s width, order, and whether it should show or be hidden, these tables are required :</p>

<ul>

<li><p>oac_column_width columns oac_datatype, oac_table, oac_curator, oac_column_width, oac_timestamp . The oac_timestamp column is a timestamp with default now, all others are text. The column width is the width in pixels that a dataTable column should have when loading. YUI&#39;s datatable scripts will still resize is as data gets queries, added, or edited. When a curator resizes a column, its corresponding value is updated here.</p>

</li>
<li><p>oac_column_order columns oac_datatype, oac_table, oac_curator, oac_column_order, oac_timestamp . The oac_timestamp column is a timestamp with default now, all others are text. The order of the columns are the default order when loaded, which is different from the order of the fields in the OA&#39;s editor frame. When a curator reorders a column, all the columns&#39;s corresponding orders are updated here.</p>

</li>
<li><p>oac_column_showhide columns oac_datatype, oac_table, oac_curator, oac_column_showhide, oac_timestamp . The oac_timestamp column is a timestamp with default now, all others are text. dataType columns can be toggled to show or hide by clicking on the corresponding field name in the OA&#39;s editor frame (when hidden the text will be grey, when showing the text will be black) ; this table stores whether to show or hide each column when the dataTable is first loaded. When a curator toggles a column to hide or show, its corresponding state is updated here.</p>

</li>
</ul>

<p>If some MOD really doesn&#39;t want this, &amp;updatePostgresColumn could probably be edited to only do this for specific $configLoaded , and this code change would have to be propagated to other MODs.</p>

<p>create_oac_columns.pl is a script to delete and re-create these column postgres tables.</p>

<h3 id="DATATYPE-POSTGRES-TABLES">DATATYPE POSTGRES TABLES</h3>

<p>When creating a new datatype, each field should have its own postgres table and postgres history table. The datatype by convention is a three-letter code. The format of each table would be &#39;&lt;datatype&gt;_&lt;field name&gt;&#39; and for history tables &#39;&lt;datatype&gt;_&lt;field name&gt;_hst&#39;, so e.g. : &#39;app_term&#39; &#39;app_term_hst&#39;, &#39;int_variationone&#39; &#39;int_variationone_hst&#39;, &#39;trp_driven_by_gene&#39; &#39;trp_driven_by_gene_hst&#39;.</p>

<p>Columns are joinkey, &lt;table_name&gt;, &lt;datatype&gt;_timestamp . The &lt;datatype&gt;_timestamp column is a timestamp with default now, all others are text. The &lt;table_name&gt; column is the same as the name of the table. e.g. the table app_term has columns named joinkey, app_term, app_timestamp ; and app_term_hst has columns named joinkey, app_term_hst, app_timestamp .</p>

<p>There are four different ways of storing data :</p>

<ul>

<li><p>text and textarea and bigtext types store text straight.</p>

</li>
<li><p>toggle type store the label of the field shown on the editor for true, and &#39;&#39; for false.</p>

</li>
<li><p>dropdown and ontology types store the ID of the chosen value.</p>

</li>
<li><p>multidropdown and multiontology types store the IDs of the chosen values, surrounded by doublequotes and comma-separated. (for this reason avoid having IDs with doublequotes in them)</p>

</li>
</ul>

<p>create_datatype_tables.pl is a script to create postgres data tables and history tables for a given datatype and tables.</p>

<h3 id="OBO-POSTGRES-TABLES">OBO POSTGRES TABLES</h3>

<p>When creating an ontology or multiontology field, a set of custom subroutines can be created in the MOD-specific perl module (called by &amp;getAnySpecific...), or the local &amp;getGenericObo... subroutines, which work off generic obo_ tables in postgres. To use the latter subroutines, in the MOD-specific perl module, set the fields&#39;s %fields to have &#39;ontology_type&#39; = &#39;obo&#39; and &#39;ontology_table&#39; = &#39;&lt;name of ontology type&gt;&#39; . The name of the ontology type is lowercase by convention. These two values are set to all fields that use that given ontology for the same MOD ; multiple datatypes can use it, and/or multiple fields in the same datatype. Also to use these subroutines, create 3 tables for each set of ontologies :</p>

<ul>

<li><p>obo_name_&lt;name of ontology type&gt; columns joinkey, &lt;table_name&gt;, obo_timestamp . The obo_timestamp column is a timestamp with default now, all others are text. This table&#39;s key is the object ID, the value is the name of the object. An object can only have one entry for a given joinkey in this table.</p>

</li>
<li><p>obo_syn_&lt;name of ontology type&gt; column joinkey, &lt;table_name&gt;, obo_timestamp . The obo_timestamp column is a timestamp with default now, all others are text. This table&#39;s key is the object ID, the value is the synonym of the object. An object could have multiple synonyms, so it could have multiple entries for the same joinkey in this table.</p>

</li>
<li><p>obo_data_&lt;name of ontology type&gt; column joinkey, &lt;table_name&gt;, obo_timestamp . The obo_timestamp column is a timestamp with default now, all others are text. This table&#39;s key is the object ID, the value is the data of the object to show in the OA&#39;s term info frame. An object can only have one set of data to show, so it can only have one entry for a given joinkey in this table. The data here will show almost exactly as stored, so html markup is stored here directly ; the exception is that newlines are replaced with &#39;&lt;br /&gt;\n&#39; in the &amp;getGenericOboTermInfo . By convention tag names and a colon are wrapped in a &#39;&lt;span style=&quot;font-weight: bold&quot;&gt;&#39;. Sections can be divided with a &#39;&lt;hr&gt;&#39;. Links and embedded images can be linked here.</p>

</li>
</ul>

<p>update_obo_oa_ontologies.pl is a script to download generic .obo files and update these 3 tables for each corresponding obo ontology type.</p>

<h2 id="GLOBALS">GLOBALS</h2>

<h3 id="OA-GLOBALS">OA GLOBALS</h3>

<p>$configLoaded is a variable to specify which MOD-specific perl module has been loaded. Refer to appropriate subroutine in &amp;asyncTermInfo &amp;asyncValidValue &amp;autocompleteXHR &amp;getTableDisplayData &amp;showLogin &amp;showMain &amp;initFields .</p>

<p>$filtersMaxAmount is the amount of filters to put in the OA&#39;s control frame. This could be stored in a postgres table at some point, and code rewritten for it. The control frame shows one filter by default, and more can be shown by changing the number in the dropdown.</p>

<p>$newRowMaxAmountNormalOa is the amount of new rows to create when pressing the &#39;New&#39; button in the normal OA.</p>

<p>$newRowMaxAmountBatchUnsafeOa is the amount of new rows to create when pressing the &#39;New&#39; button in the batch unsafe OA.</p>

<p>%fieldIdToValue is a hash to map IDs of data in postgres to what should be displayed in the dataTable when querying. When a query will load a lot of values into the dataTable it&#39;s wasteful to query each ID to displayValue conversion multiple times for a single ID, so the values are stored in this hash and not re-queried if they already exist. The first key is the dropdown_type for dropdown / multidropdown fields ; for ontology / multiontology fields with simple obo_ tables, it&#39;s the &#39;obo_name_&lt;ontology_table&gt; ; for ontology / multiontology fields with a custom specific lookup, it&#39;s the ontology type. The second key is the ID of the value. The value of the hash is what should be displayed, &quot;display_value&lt;span style=&#39;display: none&#39;&gt;id&lt;/span&gt;&quot; ; the display_value is usually the name of the object, but it could be the ID in cases like WBPapers ; the id is the ID of the object ; the &lt;span&gt;s are html element tags to keep the id hidden in the dataTable display, and are used for getting the IDs in the cell when a dataTable row is clicked and they should be loaded to the OA&#39;s editor frame&#39;s corresponding fields (some display_values map to multiple IDs in some datatypes).</p>

<p>%fields stores options for the datatype configuration&#39;s individual fields, in the format $fields{&lt;datatype&gt;}{&lt;field_name&gt;}{&lt;option&gt;} . Its values are initialized from the MOD-specific perl module, and returned here.</p>

<p>%datatypes stores options for each datatype configuration as a whole, in the format $datatypes{&lt;datatype&gt;}{&lt;option&gt;} . Its values are initialized from the MOD-specific perl module, and returned here.</p>

<h3 id="OTHER-GLOBALS">OTHER GLOBALS</h3>

<p>$dbh is the DBI database handle for postgreSQL queries.</p>

<p>$query is the CGI query object.</p>

<p>$var is a placeholder variable when getting values from the form.</p>

<p>$action is the action performed by the curator on the form.</p>

<h2 id="SUBROUTINES">SUBROUTINES</h2>

<h3 id="LOGIN-SUBROUTINE">LOGIN SUBROUTINE</h3>

<p>&amp;showLogin if there&#39;s no curator $action, show a login page, call &amp;initFields and the appropriate subroutine for the curator&#39;s $action . &amp;showLogin has an html form that gets the login options from the MOD-specific perl module, and also shows gives options for max_per_query and batch_unsafe_flag . max_per_query is the maximum amount of entries to get from postgres when querying for previously curated data ; returning too many entries would slow down or freeze the browser depending on the user&#39;s computer and the amount of entries ; a curator can query multiple times to keep getting more values. batch_unsafe_flag is a toggle for the javascript to use the batchUnsafeUpdateDataTableValues function instead of the defaul normalSafeUpdateDataTableValues ; the normal way sends an AJAX call for each row to change, gives individual errors, and updates the dataTable as appropriate ; the batch_unsafe way is a faster way to update multiple postgres entries / dataTable rows, with a single AJAX call for all of them, a single error for all entries, and does not reflect changes in the dataTable ; if this value is toggled, the OA&#39;s editor frame has a different background and warning text.</p>

<h3 id="INITIALIZATION-SUBROUTINE">INITIALIZATION SUBROUTINE</h3>

<p>&amp;initFields calls the MOD-specific subroutine to initialize %fields and %datatypes for that curator-datatype. It also queries the oac_ postgres tables for that curator-datatype.</p>

<h3 id="SHOW-MAIN-SUBROUTINE">SHOW MAIN SUBROUTINE</h3>

<p>&amp;showMain gets the login variables, IP address, calls the MOD-specific login subroutine, and creates an html page with four frames :</p>

<ul>

<li><p>&#39;editor&#39; frame, calling action &#39;editorFrame&#39; and passing all variables.</p>

</li>
<li><p>&#39;obo&#39; frame, calling action &#39;oboFrame&#39;.</p>

</li>
<li><p>&#39;controls&#39; frame, calling action &#39;controlsFrame&#39; and passing the chosen &#39;datatype&#39; and &#39;curator_two&#39;.</p>

</li>
<li><p>&#39;table&#39; frame, calling action &#39;tableFrame&#39; and passing the chosen &#39;datatype&#39; and &#39;curator_two&#39;.</p>

</li>
</ul>

<h3 id="SHOW-EDITOR-SUBROUTINES">SHOW EDITOR SUBROUTINES</h3>

<p>&amp;showEditor shows the OA editor frame. Gets user values and makes hidden inputs for the ontology_annotator.js to get them as needed. If the batch_unsafe_flag is set, the background color of the frame is different. Creates an html table, and for each %fields&#39;s datatype field, it sets some variables :</p>

<ul>

<li><p>$freeForced is a flag for whether an dropdown / multidropdown / ontology / multiontology should force values or allow anything that doesn&#39;t match in them. By default all are forced.</p>

</li>
<li><p>$span_type has the html character to display for dropdown / multidropdown (&amp;and), ontology / multiontology (&amp;or), others display nothing. This value shows between the input and the query button. dropdown / multidropdown values can have the html characer clicked to see all possible values.</p>

</li>
<li><p>$field_type is the $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;type&#39;} . Depending on the type, a different &amp;showEditor... subroutine is called.</p>

</li>
<li><p>$border_style is the type of border the $span_type html character should have to make it look like a button.</p>

</li>
<li><p>$tab is the $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;tab&#39;} . It also adds to %tabs which keeps track of how many tabs should be displayed. The html tr element has a class $tab to determine whether to show that table row depending on which tab has been clicked.</p>

</li>
<li><p>$inline_field is the $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;inline&#39;} . Fields that begin with &#39;INSIDE_&#39; are skipped, because they are the second or later field to display inline.</p>

</li>
<li><p>$input_size is the $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;input_size&#39;} . This is the size of the html input element. There is a default input size and default input size for inline fields.</p>

</li>
<li><p>$cols_size is the $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;cols_size&#39;} . This is the cols size of the html textarea element.</p>

</li>
<li><p>$rows_size is the $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;rows_size&#39;} . This is the rows size of the html textarea element.</p>

</li>
<li><p>$colspan is the size of the html colspan. By default it is 3, allowing inline fields to have a size of 1 for labels and inputs.</p>

</li>
</ul>

<p>and creates a table row, calling &amp;generateEditorLabelTd to generate and append the field&#39;s label to the row, then depending on the $field_type it calls the appropriate &amp;showEditor... subroutine(s) to create the html elements to display in the table. Fields that are neither multidropdown nor multiontology also generate and print the value from &amp;generateEditorSpantypeQuerybuttonTds , because these fields are a single table row so their creation subroutines don&#39;t add this. Creates a &#39;Reset&#39; button that floats right, which calls ontology_annotator.cgi function resetButton which reloads the obo frame, removes all rows from the dataTable, and blanks all editor values. Shows the configuration loaded from $datatypes{$datatype}{label}. Creates a tab html button for each tab in %tabs which when clicked shows only table rows corresponding to that tab. If batch_unsafe_flag is set, a warning text is displayed in an html span element.</p>

<p>If the $field_type corresponds to something that should show multiple fields in one row, $colspan changes to more values will fit, and the appropriate separate &amp;showEditor... subroutines are called.</p>

<p>&amp;generateEditorLabelTd generates an html td element, passing in the field and datatype, and returning the td generated td element. Gets &lt;label&gt; from $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;label&#39;} . Creates a td element with id &#39;label_&lt;field&gt;&#39; and &lt;label&gt; for text, the returns it.</p>

<p>&amp;generateEditorSpantypeQuerybuttonTds generates two html td elements, passing in the field, border_style, and span_type ; and returning the created td elements. The first td element has a span with id &#39;type_&lt;field&gt;&#39;, html style&#39;s border-style &lt;border_style&gt; and border-color &#39;grey&#39;, and text of &lt;span_type&gt;. The second td element has a button with id &#39;button_&lt;field&gt;&#39; and text &#39;query&#39;.</p>

<p>&amp;showEditorText creates an html td element for normal input fields, passing in the field, datatype, input_size, and colspan ; and returning the created td element. Creates a td element of fixed 150 width, colspan &lt;colspan&gt;, and an input field with id &#39;input_&lt;field&gt;&#39; and size &lt;input_size&gt;. The width is fixed because of some auto-sizing to nothing if there is no size.</p>

<p>&amp;showEditorTextarea is like &amp;showEditorText but is a textarea instead of an input html element.</p>

<p>&amp;showEditorBigtext is like &amp;showEditorText but has an additional html div element with id &#39;container_bigtext_&lt;field&gt;&#39;, which contains a textarea with id &#39;textarea_bigtext_&lt;field&gt;&#39;, with rows &lt;rows_size&gt; or 20 if no value given, cols &lt;cols_size&gt; or &lt;input_size&gt; if no value given, and default style &#39;display:none&#39;. When the input field is clicked, the ontology_annotator.js transfers the value to the textarea, hides the input, and shows the textarea. When blurring the textarea, the ontology_annotator.js transfers the value to the input, hides the textarea, and shows the input. This allows editing and seeing a large amount of text in a textarea, but normally only seeing a smaller input that takes up less space.</p>

<p>&amp;showEditorQueryonly creates an html td element for query only fields, passing in the field, datatype, colspan ; and returning the created td element. Creates a td element with id &#39;queryonly_&lt;field&gt;&#39;, colspan &lt;colspan&gt;, align &#39;center&#39;, and width of &lt;colspan&gt; / 3 * 100% which makes it take up the full width. When queried jsonFieldQuery gets the custom query from $fields{&lt;datatype&gt;}{&lt;field&gt;}{queryonlySub} instead of the field&#39;s non-existent postgres table.</p>

<p>&amp;showEditorToggle creates an html td element for query only fields, passing in the field, datatype, colspan ; and returning the created td element. Creates a td element with id &#39;toggle_&lt;field&gt;&#39;, colspan &lt;colspan&gt;, align &#39;center&#39;, and width of &lt;colspan&gt; / 3 * 100% which makes it take up the full width. Background color is &#39;white&#39; to show &#39;false&#39; and when clicked, ontology_annotator.js toggles the background color to &#39;red&#39; to show &#39;true&#39;.</p>

<p>&amp;showEditorDropdown creates an html td element for dropdown fields, passing in the field, datatype, input_size, colspan, freeForced ; and returning the created td element. Creates a td element of fixed width 150 and colspan &lt;colspan&gt; containing an html span of id &#39;container&lt;freeForced&gt;&lt;field&gt;AutoComplete&#39;, used by YUI to create autocomplete fields. This span contains an html div element with id &#39;&lt;freeForced&gt;&lt;field&gt;AutoComplete&#39; and class &#39;div-autocomplete&#39;, which contains an html input element with id &#39;input_&lt;field&gt;&#39; and size &lt;input_size&gt;, and another html div element with id &#39;&lt;freeForced&gt;&lt;field&gt;Container&#39;. Anything typed in the input field will have the ontology_annotator.js make an AJAX call to the CGI with action &#39;autocompleteXHR&#39; to get matching values for the corresponding datatype-field-curator, and display them in the container div. Dropdown fields can click the span_type to pass a blank as the query value, returning all values for that datatype-field-curator.</p>

<p>&amp;showEditorOntology is identical to &amp;showEditorDropdown but has a separate subroutine, should the display need to become different. The ontology_annotator.js does not set the span_type to query for all values, since ontology fields have too many values for this to be practical.</p>

<p>&amp;showEditorMultidropdown creates html td and tr elements for multidropdown fields, passing in the field, datatype, input_size, span_type, colspan, freeForced ; and returning the created td and tr elements. Gets &lt;tab&gt; from $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;tab&#39;} . Generates a dropdown td element with &amp;showEditorDropdown . Generates html span_type and query button with &amp;generateEditorSpantypeQuerybuttonTds . Closes the html tr element. Creates a new html tr element with class &lt;tab&gt;. Adds to it a blank html td element for indentation to show it is part of the same field despite being a new row. Adds to it another html td element containing an html select element with id &#39;select_&lt;field&gt;&#39; of size 1 allowing multiple values to be selected. Adds another html td element, containing an html button with id &#39;button_remove_&lt;field&gt;&#39; and label &#39;remove&#39;. When adding a new value in the autocomplete input element, ontology_annotator.js adds it to the select element, and resizes the select element to a size equal to the elements in the field so all values always show in it. Clicking the remove button calls ontology_annotator.js removeSelectFieldEntriesListener which removes all selected values from the select element and resizes the select element to a size equal to the elements in the select field so it takes up no more space than needed to show all values.</p>

<p>&amp;showEditorMultiontology is identical to &amp;showEditorMultidropdown but has a separate subroutine, should the display need to become different. The ontology_annotator.js does not set the span_type to query for all values, since ontology fields have too many values for this to be practical.</p>

<h3 id="SHOW-OBO-SUBROUTINES">SHOW OBO SUBROUTINES</h3>

<p>&amp;showObo shows the OA obo / term information frame. Gets text, term_id, datatype, field, obotable from the form. Creates an html div element with id &#39;termInfo&#39; with &lt;term_data&gt; as text. Creates an html div element with id &#39;myObo&#39; as a placeholder for debugging messages. The &lt;term_data&gt; comes from &amp;getAnyTermInfo . The ac_value is the &#39;&lt;term_name&gt; ( &lt;term_id&gt; ) &#39; from &lt;term_data&gt;. Links are created and added at the top : an arrow left (html &amp;lArr; character) to go back a frame ; an arrow right (html &amp;rArr; character) to go forward a frame ; a &quot;check mark&quot; (html &amp;radic; character) to set the value of the &#39;input_&lt;field&gt;&#39; to &lt;ac_value&gt;, focus, and blur (to trigger the ontology_annotator.js blur action to update postgres and the dataTable. The value of the name tag is moved inside the span to bold it.</p>

<p>&amp;getAnyTermInfo generates term_data, passing in datatype, field, term_id ; and returning the term data. If the field&#39;s ontology_type is &#39;obo&#39;, it calls &amp;getGenericOboTermInfo to get data from generic postgres obo_ tables. Otherwise it checks the $configLoaded and calls the MOD-specific subroutine to get term info ; if any are loaded it calls &amp;getAnySpecificTermInfo .</p>

<p>&amp;getGenericOboTermInfo generates term_data from generic postgres obo_ tables, passing in datatype, field, userValue ; and returning the term data. Gets the curator from the form. Get the obotable from $fields{&lt;datatype&gt;}{&lt;field&gt;}{&#39;ontology_table&#39;} . Gets the obo_ joinkey from the userValue. Query postgres obo_data_&lt;obotable&gt;. Return blank &#39;&#39; if there is no data. Replace newlines with html br elements + newlines. If the data has &#39;action=oboFrame&#39;, globally replace it with same + &quot;field=&lt;field&gt;&amp;datatype=&lt;datatype&gt;&amp;curator_two=&lt;curator&gt;&quot;, which is necessary to have the proper values in the obo frame when traveling forward and back, and selecting a value. Return</p>

<h3 id="SHOW-CONTROLS-SUBROUTINE">SHOW CONTROLS SUBROUTINE</h3>

<p>&amp;showControls shows the OA controls frame.</p>

<p>Gets the datatype from the form.</p>

<p>Creates an html div element with id &#39;loadingImage&#39; to hold the image when loading data from a postgres query.</p>

<p>Creates a hidden html input element with id &#39;newRowMaxAmountValue&#39; that stores the maximum amount of new rows to create with the &#39;New&#39; button. This value is $newRowMaxAmountNormalOa by default, or $newRowMaxAmountBatchUnsafeOa if the $batch_unsafe_flag is set to &#39;true&#39;.</p>

<p>Creates an html span element with id &#39;newRowAmount&#39; with default value 1, to determine the amount of rows that will be created when pressing the button &#39;New&#39; ; when clicked the ontology_annotator.js calls changeNewRowAmountPromptListener which gives a prompt to enter a value up to $newRowMaxAmount .</p>

<p>Creates an html button element with id &#39;newRow&#39; to create a new dataTable row ; when clicked the ontology_annotator.js calls newRowButtonListener which does an AJAX call to the CGI with action &#39;newRow&#39;, creating and getting a new pgid / joinkey, then doing another AJAX call to the CGI with action jsonFieldQuery passing the new pgid and getting the created row to load and highlight in the dataTable.</p>

<p>Creates an html button element with id &#39;duplicateRow&#39; to create a new dataTable row for each dataTable row that is selected, all values except for pgid / joinkey are duplicated ; when clicked the ontology_annotator.js calls duplicateRowButtonListener which does an AJAX call to the CGI with action &#39;duplicateByPgids&#39;, getting the newly created pgids, doing another AJAX call to the CGI with action jsonFieldQuery passing the new pgids and getting the created rows to load and highlight in the dataTable.</p>

<p>Creates an html button element with id &#39;deleteRow&#39; to delete selected dataTable rows ; when clicked the ontology_annotator.js calls deleteRowButtonListener which does an AJAX call to the CGI with action &#39;deleteByPgids&#39;, deleting the entries from the postgres tables and from the dataTable.</p>

<p>Creates an html button element with id &#39;checkData&#39; to optionally check data in the dataTable against datatype-specific constraints ; when clicked the ontology_annotator.js calls checkDataButtonListener which does an AJAX call to the CGI with action &#39;checkDataByPgids&#39;, if return values are not &#39;OK&#39;, a popup window is openend and focused, loading the messages from the return value.</p>

<p>Creates a hidden html input element with id &#39;filtersMaxAmount&#39; that stores the maximum amount of filters.</p>

<p>Creates an html select element with id &#39;filtersAmount&#39;, and options 1 through the maximum amount of filters. When the form loads or this value changes, the ontology_annotator.js calls updateFiltersAmount which shows only that amount of filtering pairs (see next paragraph).</p>

<p>For the maximum amount of filters, creates pairs of html elements. An html select element with id &#39;filterType&lt;count&gt;&#39; with options &#39;all&#39; and each of the fields from $fields{&lt;datatype&gt;}. An html input element with id &#39;filterValue&lt;count&gt;&#39; for the curator&#39;s text to filter on. When something is typed into an input, the ontology_annotator.js will show only the dataTable rows that contain the typed text in the corresponding &#39;filterType&lt;count&gt;&#39; column.</p>

<h3 id="SHOW-TABLE-SUBROUTINE">SHOW TABLE SUBROUTINE</h3>

<p>&amp;showTable shows the OA dataTable frame. This frame loads all the required .css and .js files into the html head element ; when reloading the form, be sure to reload this frame to update those files.</p>

<p>Gets the datatype from the form.</p>

<p>The html body element needs to have class &#39;yui-skin-sam&#39;. When resized, the ontology_annotator.js calls resizeDataTable which sets the height of html div elements with class &#39;yui-dt-bd&#39;, because they tend to be too big and create scrollbars.</p>

<p>For each field from $fields{&lt;datatype&gt;}, create an html input element of class &#39;fields&#39; with value &lt;field&gt;. For each field&#39;s tag, get data from $fields{&lt;datatype&gt;}{&lt;field&gt;}{&lt;tag&gt;} and create &quot;&#39;&lt;tag&gt;&#39; : &#39;&lt;data&gt;&#39;&quot; pairs to join with commas, and store in an html input field with id &#39;data_&lt;field&gt;&#39;. The ontology_annotator.js looks up all the fields from the inputs of class &#39;fields&#39;, and gets the fieldsData from each field&#39;s &#39;data_&lt;field&gt;&#39; html input element.</p>

<h3 id="JSON-FIELD-QUERY-SUBROUTINES">JSON FIELD QUERY SUBROUTINES</h3>

<p>&amp;jsonFieldQuery generates a text page for returning AJAX queries for postgres data. Gets userValue, datatype, field, maxPerQuery, allDataTableIds from form ; and returns JSON of return message and entries for data for each postgres joinkey / dataTable row. userValue is what to query for, datatype is the datatype to query for, field is the datatype&#39;s field to query on, maxPerQuery is the maximum rows to return, allDataTableIds are the joinkeys already in the dataTable that should be skipped when querying. Fields of type dropdown or multidropdown check the MOD-specific perl module for the subroutine to have their values added to $fieldType{&lt;dropdown_type&gt;}{&lt;id&gt;} = &lt;autocomplete_value&gt; where the autocomplete_value has the id hidden in a &#39;display: none&#39; html span element, for loading into the dataTable. The pgtable to query is the &#39;&lt;datatype&gt;_&lt;field&gt;&#39;, but if the field is &#39;id&#39;, it should instead query the tables from $datatypes{&lt;datatype&gt;}{highestPgidTables} . For each table to query : If the field type is multiontology or multidropdown, the value to query should have doublequotes around it ; query for the userValue on the table where the joinkey is not already in the dataTable in descending timestamp order. If the field type is ontology or dropdown ; query for the userValue on the table where the joinkey is not already in the dataTable in descending timestamp order. If the field type is neither, and the userValue to query has three or more characters, do an exact query ; if it has less than three characters do a substring query ; query for the userValue on the table where the joinkey is not already in the dataTable in descending timestamp order. If the field type is queryonly, remove the crafted queries, because queryonly fields do not correspond to postgres tables, and instead get the postgres query from $fields{&lt;datatype&gt;}{&lt;field&gt;}{queryonlySub} . Query postgres for those queries, and get the joinkeys / pgids, ignoring results over the maxPerQuery limit ; create returnMessage of values the query found. For each $fields{&lt;datatype&gt;} that has a postgres table, query for the data corresponding to the joinkeys to return, filtering the data through &amp;getTableDisplayData and storing it in $hash{&lt;joinkey&gt;}{&lt;field&gt;} . Print to text page JSON format representation of hash, with the returnMessage as the first entry, and each joinkey&#39;s data as the next entries.</p>

<p>&amp;getTableDisplayData converts data to proper JSON-format data, and if appropriate to the MOD-specific perl module adds any specific ontology or multiontology to the %fieldIdToValue. Passes in datatype, field, data ; and returns formatted data. If the field is of type dropdown or multidropdown, get the dropdown_type from $fields{&lt;datatype&gt;}{&lt;field&gt;}{dropdown_type} ; if data exists in $fieldIdToValue{&lt;dropdown_type&gt;}{&lt;data&gt;} use that as the data value. If the field is of type multiontology or ontology, and the field&#39;s ontology_type is &#39;obo&#39;, call &amp;getGenericOboIdToValue ; otherwise check $configLoaded and call the appropriate subroutine ; if any are loaded it calls &amp;getAnySpecificIdToValue and updates %fieldIdToValue from values there. Any data is cleaned through &amp;parseJson .</p>

<p>&amp;getGenericOboIdToValue converts generic obo values from postgres values (ids) to what someone types for dataTable display, passing in datatype, field, data ; and returning the parsed data. Get ontology_table from $fields{&lt;datatype&gt;}{&lt;field&gt;}{ontology_table} . Get obotable as &#39;obo_name_&lt;ontology_table&gt;&#39;. Strip data of doublequotes (if an Id has a doublequote the lookup here will fail), split user data on commas in case it&#39;s multiontology data, and for each id : Check if it has already been looked up in $fieldIdToValue{&lt;obotable&gt;}{&lt;id&gt;} , using that value if so ; otherwise query the postgres table &lt;obotable&gt; for a joinkey of value &lt;id&gt;, and if matching create a value being the postgres table value + an html span element with style &#39;display: none&#39; containing the &lt;id&gt; / joinkey ; if the field&#39;s type is multiontology add surrounding doublequotes ; assign this id-value pair to $fieldIdToValue{&lt;obotable&gt;}{&lt;id&gt;} for future lookup, and to the results to return. Join results with commas and return.</p>

<p>&amp;getAnyMultidropdownIdToValue converts multidropdown postgres values (ids) to what someone types for dataTable display, passing in dropdown_type and data ; and returning the parsed data. Strip data of doublequotes (if an Id has a doublequote the lookup here will fail), split user data on commas in case it&#39;s multidropdown data, and for each id : Check if it has already been looked up in $fieldIdToValue{&lt;dropdown_type&gt;}{&lt;id&gt;} , using that value if so. Join results with doublequote-comma-doublequote, wrap in doublequotes, and return.</p>

<p>&amp;parseJson escapes some xml characters, passing in data and returning the cleaned data. Newlines are globally replaced with spaces. Doublequotes are espaced with backslashes. Literal newlines are stipped.</p>

<h3 id="AUTOCOMPLETE-SUBROUTINES">AUTOCOMPLETE SUBROUTINES</h3>

<p>&amp;autocompleteXHR generates a text page for returning AJAX queries for autocompletion fields. From the form gets datatype, field, and words from the default YUI autocomplete field &#39;query&#39; ; and prints rows of autocomplete values for the container html div element. Words are lower cased. If the field type is dropdown or multidropdown call &amp;getAnySimpleAutocomplete . If the field type is ontology or multiontology, and the field&#39;s ontology_type is &#39;obo&#39;, call &amp;getGenericOboAutocomplete ; otherwise check $configLoaded and call the appropriate subroutine ; if any are loaded it calls &amp;getAnySpecificAutocomplete . Print result matches.</p>

<p>&amp;getAnySimpleAutocomplete generates ordered autocomplete matches for dropdown or multidropdown fields, passing in datatype, field, words ; and returning the result matches. Get dropdown_type from $fields{&lt;datatype&gt;}{&lt;field&gt;}{dropdown_type} . max_results is the maximum amount of autocomplete objects to return, by default it is 40, but if there are 5 or more characters typed it becomes 500 to match with &amp;getGenericOboAutocomplete. Call the MOD-specific perl module subroutine to get the values for the dropdown_type. Return matching values.</p>

<p>&amp;getGenericOboAutocomplete generates autocomplete matches from generic postgres obo_ tables, passing in datatype, field, words ; and returning the result matches. Get ontology_table from $fields{&lt;datatype&gt;}{&lt;field&gt;}{ontology_table} . max_results is the maximum amount of autocomplete objects to return, by default it is 30, but if there are 5 or more characters typed it becomes 500 because some GO ontologies have hundreds of terms with the same words. Singlequotes are escaped for postgres queries. The three tabletypes of postgres obo_ tables are name (id to name mapping), syn (id to synonyms), data (id to full data for term info display). Results are stored in a tied hash to maintain order. For each tabletype obotable is &#39;obo_&lt;tabletype&gt;_&lt;ontology_table&gt;&#39;. The column to match on is the table name, but for tabletype &#39;data&#39; query the joinkey column. Query the table matching the column for lower cased values starting with &lt;words&gt;, sorted by column, with a limit of max_results to avoid getting too many results that won&#39;t show anyway. Get up to max_results, getting the data as &#39;&lt;data&gt; ( &lt;id&gt; ) &#39;. If the tabletype is &#39;syn&#39; or &#39;data&#39; query the name tabletype to get the object&#39;s name. If the tabletype is &#39;syn&#39; append a &#39;[&lt;name&gt;]&#39; ; if the tabletype is &#39;data&#39;, replace the match with &#39;&lt;name&gt; ( &lt;id&gt; ) &#39;. Query again the same way matching for the word anywhere in the field except for in the beginning. If there are more matches than max_results replace the last value with &#39;more ...&#39; to let the user know there are more values. Return matches.</p>

<h3 id="ASYNC-TERM-INFO-SUBROUTINE">ASYNC TERM INFO SUBROUTINE</h3>

<p>&amp;asyncTermInfo generates a text page for returning AJAX queries for term information of fields of type ontology or multiontology. From the form gets datatype, field, userValue ; and prints term information for the termInfo html div element of the OA&#39;s obo frame. Calls &amp;getAnyTermInfo (see SHOW OBO SUBROUTINES ).</p>

<h3 id="ASYNC-VALID-VALUE-SUBROUTINES">ASYNC VALID VALUE SUBROUTINES</h3>

<p>&amp;asyncValidValue generates a text page for returning AJAX queries to check if an autocomplete value is valid. From the form gets datatype, field, userValue ; and prints whether it is &#39;OK&#39; or has an error message. If the field type is dropdown or multidropdown call &amp;getAnySimpleValidValue . If the field type is ontology or multiontology, and the field&#39;s ontology_type is &#39;obo&#39;, call &amp;getGenericOboValidValue ; otherwise check $configLoaded and call the appropriate subroutine ; if any are loaded it calls &amp;getAnySpecificValidValue . Print result matches.</p>

<p>&amp;getAnySimpleValidValue checks whether a value exists in a dropdown or multidropdown fields, passing in datatype, field, userValue ; and returning &#39;true&#39; or &#39;false&#39;. Get dropdown_type from $fields{&lt;datatype&gt;}{&lt;field&gt;}{dropdown_type} . Call the MOD-specific perl module subroutine to set the values for the dropdown_type, then loop through them returning &#39;true&#39; if found, returning false if there is no match.</p>

<p>&amp;getGenericOboValidValue checks whether a value exists in a generic postgres obo_ tables, passing in datatype, field, userValue ; and returning &#39;true&#39; or &#39;false&#39;. Get ontology_table from $fields{&lt;datatype&gt;}{&lt;field&gt;}{ontology_table} . Get obotable as &#39;obo_name_&lt;ontology_table&gt;&#39;. Get the value and joinkey from the userValue. Convert userValue from URL to postgres format with &amp;fromUrlToPostgres for postgres query. If both joinkey and value have an entry in the postgre obotable return &#39;true&#39;, otherwise return &#39;false&#39;.</p>

<h3 id="UPDATE-POSTGRES-TABLE-FIELD-SUBROUTINES">UPDATE POSTGRES TABLE FIELD SUBROUTINES</h3>

<p>&amp;updatePostgresTableField generates a text page for returning AJAX updates, called when an editor field is blurred, to update corresponding postgres tables. From the form gets datatype, field, pgid, newValue ; and prints &#39;OK&#39; if successful or error message. If the field&#39;s type is multiontology or multidropdown get the ids from within the html span elements, join them with doublequotes, and wrap them in doublequotes ; otherwise if the field has an html span element, get the id from within it ; otherwise the value stays the same. The postgres table is &#39;&lt;datatype&gt;_&lt;field&gt;&#39;, call &amp;updatePostgresByTableJoinkeyNewvalue and print whether it is &#39;OK&#39; or has an error message.</p>

<p>&amp;updatePostgresByTableJoinkeyNewvalue updates postgres data tables for a given table and pgids, passing in table, pgid, newValue ; and returning &#39;OK&#39; if successful or error message. Convert newValue from URL to postgres format with &amp;fromUrlToPostgres for postgres command, wrap in singlequotes, and convert to utf8 if it is not ; if there&#39;s no newValue set it to NULL. ontology_annotator.js has a batchUnsafeUpdateDataTableValues mode to update multiple table entries at once for multiple pgids, so split on comma to get array of pgids. For each pgid delete that pgid&#39;s entry from the main table, insert NULL or value into the postgres history table, and if there&#39;s a value insert into the postgres data table. If there are errors return them, otherwise return &#39;OK&#39;.</p>

<h3 id="UPDATE-POSTGRES-COLUMN-SUBROUTINE">UPDATE POSTGRES COLUMN SUBROUTINE</h3>

<p>&amp;updatePostgresColumn generates a text page for returning AJAX updates, called when a dataTable column setting changes, to update corresponding postgres tables. From the form gets datatype, table, curator, column action, newValue ; and prints &#39;OK&#39; if successful or error message. Set the pgtable depending on the column action. Delete from the table for the curator, datatype, and table. For columnWidth and columnShowHide insert new value. For columnOrder get the tables in order and insert them with count. Print whether it is &#39;OK&#39; or has an error message.</p>

<h3 id="NEW-ROW-SUBROUTINES">NEW ROW SUBROUTINES</h3>

<p>&amp;newRow generates a text page for returning AJAX updates of new datatype object creation of dataTable / postgres table data. From the form gets amount of rows to create, datatype, and curator ; and prints whether the creation is &#39;OK&#39; or has an error message. Get the highest used pgid from &amp;getHighestPgid . If it&#39;s not a digit give an error. If there are less than 2 rows to create, make 1 row. For each row to create get a new pgid, if there&#39;s a newRowSub for the datatype use it, if there are errors (non digits response) add them to list to print, add created pgids to list of created pgids. If there are errors print them, otherwise print &#39;OK&#39; ; followed by distinct divider for ontology_annotator.js newRowButtonListener to separate data ; followed by the pgids created with comma-separation.</p>

<p>&amp;getHighestPgid gets the highest used pgid from the postgres tables, passing in the datatype ; and returning the highest pgid. Gets the postgres tables to check from $datatypes{&lt;datatype&gt;}{highestPgidTables} and queries for the highest joinkey as an integer, returning it, or gives an error message.</p>

<h3 id="DUPLICATE-BY-PGIDS-SUBROUTINE">DUPLICATE BY PGIDS SUBROUTINE</h3>

<p>&amp;duplicateByPgids generates a text page for returning AJAX updates of duplications of dataTable / postgres table data. From the form gets datatype and idsToDuplicate ; and prints whether the duplications are &#39;OK&#39; or have an error message, as well as a distinct divider and the newly duplicated pgids. Get the highest used pgid from &amp;getHighestPgid (see NEW ROW SUBROUTINES ). If it&#39;s not a digit give an error. Split idsToDuplicate on comma to get array of pgids. For each pgid get a new pgid to create and loop through each datatype&#39;s field, skipping &#39;id&#39; field and fields of type &#39;queryonly&#39;, making the postgres table as &#39;&lt;datatype&gt;_&lt;field&gt;&#39;, querying the pgid to duplicate for data, and if it has data calling &amp;updatePostgresByTableJoinkeyNewvalue on the table, new pgid, and retrieved data. If there are errors print them, otherwise print &#39;OK&#39; ; followed by distinct divider for ontology_annotator.js duplicateRowButtonListener to separate data ; followed by comma-joined duplicated pgids.</p>

<h3 id="DELETE-BY-PGIDS-SUBROUTINE">DELETE BY PGIDS SUBROUTINE</h3>

<p>&amp;deleteByPgids generates a text page for returning AJAX updates of deletions from dataTable / postgres table data. From the form gets datatype and idsToDelete ; and prints whether the deletions are &#39;OK&#39; or have an error message. Split idsToDelete on comma to get array of pgids. For each pgid loop through each datatype&#39;s field, skipping &#39;id&#39; field and fields of type &#39;queryonly&#39;, making the postgres table as &#39;&lt;datatype&gt;_&lt;field&gt;&#39;, querying it for a row with that pgid, and if it has some call &amp;updatePostgresByTableJoinkeyNewvalue on the table, pgid, and blank &#39;&#39; data. If there are errors print them, otherwise print &#39;OK&#39;. This should never print anything because postgres deletes don&#39;t give errors and NULL inserts are skipped.</p>

<h3 id="CHECK-DATA-BY-PGIDS-SUBROUTINES">CHECK DATA BY PGIDS SUBROUTINES</h3>

<p>&amp;checkDataByPgids generates a text page for returning AJAX queries to check if dataTable data passes tests for the datatype ; one test can be whether specific tables require data, the other is for custom constraints (e.g. a field&#39;s data fits a format, or any of N fields have data). From the form gets datatype, allDataTableIds ; and prints whether it is &#39;OK&#39; or has an error message. Checks $datatypes{&lt;datatype&gt;}{constraintTablesHaveData} to see if there is a list of tables that must have data for the datatype, calling &amp;checkDataInPgTable . Checks $datatypes{$datatype}{constraintSub} to see if there is a special constraint subroutine for additional checks, calling it. If either check gets an error message, print the error message(s), otherwise print &#39;OK&#39;.</p>

<p>&amp;checkDataInPgTable checks whether all pgids in the dataTable have data for a list of tables for the datatype, passing in datatype, arrayref, and allDataTableIds ; and returning any error messages or blank &#39;&#39;. arrayref is the reference to the array of tables that should have data in $datatypes{&lt;datatype&gt;}{constraintTablesHaveData} . allDataTableIds are the comma-separated pgids passed in from the AJAX call to &amp;checkDataByPgids . Gets list of ids by splitting on comma, creates joinkeys by joining on singlequote-comma-singlequote for postgres query. If arrayref has no tables returns (blank). For each table makes the postgres table as &#39;&lt;datatype&gt;_&lt;table&gt;&#39;, querying the table and joinkeys, hashing all joinkeys and tables. For each pgid to check, if there&#39;s no hash entry adds error to returnMessage ; otherwise checks each table for id-table in the hash, if there&#39;s no value add to list of tablesMissingData, then add all pgid-tablesMissingData to returnMessage. Return returnMessage.</p>


</body>

</html>


